PROCEDURE:

CREATE DEFINER=`root`@`localhost` PROCEDURE `aggiungi_cliente`(
	in var_codiceFiscale VARCHAR(20),
	in var_nome VARCHAR(25),
	in var_cognome VARCHAR(15),
	in var_username VARCHAR(15))
BEGIN

	declare var_PT VARCHAR(20);
	IF (PalestraDB.check_cf(var_codiceFiscale) is FALSE) THEN 
		signal sqlstate '45000' set message_text = 'CODICE FISCALE NON VALIDO';
	END IF;
	
    -- Selezione PT con meno clienti
	SELECT PersonalTrainer.CF into var_PT
	FROM PersonalTrainer
	LEFT JOIN Clienti ON PersonalTrainer.CF = Clienti.PT
	GROUP BY PersonalTrainer.CF
	ORDER BY COUNT(Clienti.PT) ASC
	LIMIT 1;
    
	-- Aggiungo Cliente
	insert into `Clienti` (`CF`, `Nome`, `Cognome`, `Username`, `PT`)
	values (var_codiceFiscale, var_nome, var_cognome, var_username, var_PT);
		
END



CREATE DEFINER=`root`@`localhost` PROCEDURE `aggiungi_pt`(
	in var_codiceFiscale VARCHAR(20),
	in var_nome VARCHAR(25),
	in var_cognome VARCHAR(15),
	in var_username VARCHAR(15))
BEGIN

	IF (PalestraDB.check_cf(var_codiceFiscale) is FALSE) THEN 
		signal sqlstate '45001' set message_text = 'CODICE FISCALE PT NON VALIDO';
	END IF;
	insert into `PersonalTrainer` (`CF`, `Nome`, `Cognome`, `Username`)
	values (var_codiceFiscale, var_nome, var_cognome, var_username);

END



CREATE DEFINER=`root`@`localhost` PROCEDURE `aggiungi_serie_esercizio`(in var_nomeEsercizio varchar(20), 
	in var_dataSessione date, 
	in var_dataInizioScheda date, 
	in var_cfClienti varchar(20),
	in var_serieCorrente int)
BEGIN
	
    declare var_serieAggiornata int;
    declare exit handler for sqlexception 
    begin
        rollback; ## Annullamento Transazione
        resignal; ## Ridirezione Segnale al Client
    end;
    IF (PalestraDB.check_ex_status_function(var_cfClienti, var_dataInizioScheda, var_nomeEsercizio, var_dataSessione) = 2) THEN 
		SIGNAL SQLSTATE '45020' SET MESSAGE_TEXT = 'STAI AGGIUNGENDO UNA SERIE AD UN ESERCIZIO NON INIZIATO.';
	END IF;
    
	-- BASSO LIVELLO DI ISOLAMENTO DATO CHE LEGGE E SCRIVE SOLO LUI
	start transaction;
		set var_serieAggiornata = var_seriecorrente + 1;
        
        UPDATE EserciziSvolti
		SET  SerieCorrente = var_serieAggiornata
		WHERE Cliente = var_cfClienti
			AND  dataInizioScheda = var_dataInizioScheda
			AND Esercizio = var_nomeEsercizio
            AND dataSessione = var_dataSessione;
        
	commit;
END



CREATE DEFINER=`root`@`localhost` PROCEDURE `archivia_scheda`(
	in var_cfCliente VARCHAR(20),
	in var_dataInizio date)
BEGIN

	declare var_dataFine date;
	declare exit handler for sqlexception
	begin
		rollback;
		resignal;
	end;

    IF (PalestraDB.check_init_session(var_cfClienti, var_dataInizioScheda) = 1) THEN 
		signal sqlstate '45004' set message_text = 'ATTENZIONE L\'UTENTE IN QUESTIONE STA
							ESEGUENDO UNA SESSIONE DI ALLENAMENTO CON LA SCHEDA CHE VUOI ARCHIVIARE.';
	END IF;
    
	start transaction;
		set var_dataFine = curdate();
        
        UPDATE Scheda
		SET DataFine = var_dataFine
		WHERE Scheda.Cliente = var_codiceFiscale AND Scheda.dataInizio = var_dataInizio;

		
	commit;
END



CREATE DEFINER=`root`@`localhost` PROCEDURE `crea_nuova_scheda`(
	in var_cfCliente VARCHAR(20))
BEGIN
	declare var_dataInizio date;
	declare exit handler for sqlexception -- QUAND'ERA CHE UNA REGISTRAZIONE PUO' FALLIRE??
	begin
		rollback;
		resignal;
	end;
	start transaction;
		-- ATTENZIONE ALLE TRANSAZIONI NON FA STRONZATE
    
		set var_dataInizio = curdate();
        -- OCCHIO ALLE TRANSAZIONI
        
        INSERT INTO `Scheda` (`DataInizio`, `Cliente`)
		values (var_dataInizio, var_cfCliente);
     
	commit;
END



CREATE DEFINER=`root`@`localhost` PROCEDURE `esegui_esercizio`(in var_nomeEsercizio varchar(20), 
	in var_dataSessione date, 
	in var_dataInizioScheda date,
	in var_cfClienti varchar(20))
BEGIN
	declare ex_status int ;
    declare esercizi_count int ;
    declare exit handler for sqlexception 
    begin
        rollback; ## Annullamento Transazione
        resignal; ## Ridirezione Segnale al Client
    end;

	start transaction;
		
        -- Verifica se tutti gli esercizi sono stati completati
		SELECT COUNT(*) INTO esercizi_count
		FROM SchedaEsercizi
		WHERE Cliente = var_cfClienti AND DataInizioScheda = var_dataInizioScheda;
	
		IF esercizi_count = 0 THEN
			SIGNAL SQLSTATE '45013' SET MESSAGE_TEXT = 'HAI GIÃ€ COMPLETATO TUTTI GLI ESERCIZI.';
		END IF;
        
		insert into `EserciziSvolti` (`Esercizio`, `dataSessione`, `dataInizioScheda`, `Cliente`, `SerieCorrente`)
        values (var_nomeEsercizio, var_dataSessione, var_dataInizioScheda, var_cfClienti, 1);
        
	commit;
END




CREATE DEFINER=`root`@`localhost` PROCEDURE `genera_report`(IN var_trainer_cf CHAR(20), IN var_dataInizio DATE, IN var_dataFine DATE)
BEGIN

	DROP TABLE IF EXISTS report_temp;
    
  -- Crea una tabella temporanea per il report
  CREATE TEMPORARY TABLE report_temp (
    cliente_codice_fiscale CHAR(20),
    cliente_nome VARCHAR(45),
    cliente_cognome VARCHAR(45),
    data_inizio_scheda DATE,
    data_sessione DATE,
    completamento DECIMAL(5,2),
    durata TIME
  );

  -- Inserisci i dati nel report temporaneo
  INSERT INTO report_temp (cliente_codice_fiscale, cliente_nome, cliente_cognome, data_inizio_scheda, data_sessione, completamento, durata)
  SELECT c.CF, c.Nome, c.Cognome, sa.DataInizio, ses.DataSessione,
         CONCAT(IFNULL((SUM(esv.SerieCorrente) / SUM(es.NumeroSerie)) * 100, 0)) AS completamento,
         TIMEDIFF(ses.OrarioFine, ses.OrarioInizio) AS durata
  FROM Clienti c
  JOIN Scheda sa ON c.CF = sa.Cliente
  JOIN SessioneDiAllenamento ses ON sa.Cliente = ses.Cliente 
                               AND sa.DataInizio = ses.dataInizioScheda
  JOIN SchedaEsercizi es ON sa.Cliente = es.Cliente 
                         AND sa.DataInizio = es.dataInizioScheda
  LEFT JOIN EserciziSvolti esv ON ses.Cliente = esv.Cliente 
                               AND ses.dataInizioScheda = esv.dataInizioScheda 
                               AND ses.DataSessione = esv.dataSessione 
                               AND es.Esercizio = esv.Esercizio
  WHERE c.PT = var_trainer_cf
    AND ses.DataSessione BETWEEN var_dataInizio AND var_dataFine
  GROUP BY c.CF, c.Nome, c.Cognome, ses.DataSessione, sa.DataInizio;

  -- Seleziona i dati dal report temporaneo per visualizzarli
  SELECT *
  FROM report_temp;

  -- Elimina la tabella temporanea
  DROP TEMPORARY TABLE report_temp;
END





CREATE DEFINER=`root`@`localhost` PROCEDURE `inizia_sessione`(in var_cfClienti varchar(20))
BEGIN
    declare var_dataInizioScheda date;
    declare var_oggi date;
    declare var_ora time;

    declare exit handler for sqlexception
	begin 
		rollback;
		resignal;
	end;

    SELECT DataInizio into var_dataInizioScheda
	FROM Scheda
	WHERE DataFine is NULL and Cliente = var_cfClienti;
    
	IF (PalestraDB.check_init_session(var_cfClienti, var_dataInizioScheda) = 2) THEN 
		signal sqlstate '45002' set message_text = 'PER OGGI TI SEI GIA ALLENATO, Sessione Iniziata e Finita.';
	END IF;
    IF (PalestraDB.check_init_session(var_cfClienti, var_dataInizioScheda) = 1) THEN 
		signal sqlstate '45004' set message_text = 'SESSIONE GIA INIZIATA MA NON FINITA.';
	END IF;
	start transaction;
		set var_oggi = curdate();
		set var_ora = curtime();
		insert into `SessioneDiAllenamento` (`dataSessione`, `OrarioInizio`, `OrarioFine`, `dataInizioScheda`, `Cliente`)
        values (var_oggi, var_ora, NULL, var_dataInizioScheda, var_cfClienti);
	commit;
END





CREATE DEFINER=`root`@`localhost` PROCEDURE `inserisci_esercizio`(
    IN var_cliente VARCHAR(20),
    IN var_esercizio VARCHAR(30),
    IN var_dataInizioScheda DATE,
    IN var_numeroRipetizioni INT,
    IN var_numeroSerie INT,
    IN var_posizione INT
)
BEGIN
	insert into `SchedaEsercizi` (`dataInizioScheda`, `Cliente`, `Esercizio`, `Posizione`, `NumeroRipetizioni`, `NumeroSerie`)
	values (var_dataInizioScheda, var_cliente, var_esercizio, var_posizione, var_numeroRipetizioni, var_numeroSerie);
END





CREATE DEFINER=`root`@`localhost` PROCEDURE `login`(
	IN var_username VARCHAR(15), 
	IN var_password VARCHAR(20), 
    OUT var_role INT)
BEGIN

	DECLARE var_enum_role ENUM("pt","segreteria","clienti") ;
    
	SELECT `Ruolo` 
    FROM `Utenti`
    WHERE `Username` = var_username AND `Password` = SHA1(var_password)
    INTO var_enum_role ;
    
    IF var_enum_role = "pt" THEN
		SET var_role = 0 ;
	ELSEIF var_enum_role = "segreteria" THEN
		SET var_role = 1 ;
	ELSEIF var_enum_role = "clienti" THEN
		SET var_role = 2 ;
	ELSE
		SET var_role = 3 ;
	END IF ;
    
END





CREATE DEFINER=`root`@`localhost` PROCEDURE `salta_esercizio`(in var_nomeEsercizio varchar(20), 
	in var_dataSessione date, 
	in var_dataInizioScheda date,
	in var_cfClienti varchar(20))
BEGIN
	
    declare exit handler for sqlexception 
    begin
        rollback; ## Annullamento Transazione
        resignal; ## Ridirezione Segnale al Client
    end;
	
	start transaction;
		
		insert into `EserciziSvolti` 
        values (var_nomeEsercizio, var_dataSessione, var_dataInizioScheda, var_cfClienti, 0);
        
	commit;
END





CREATE DEFINER=`root`@`localhost` PROCEDURE `scegli_scheda_archiviata`(in var_CF_Cliente varchar(20), in var_dataScheda date)
BEGIN
	-- SET TRANSACTION ISOLATION LEVEL READ COMMITTED ;
	start transaction;
    
		SELECT dataInizioScheda, Posizione, Esercizio, NumeroSerie, NumeroRipetizioni
        FROM Scheda s join SchedaEsercizi se on (DataInizio = dataInizioScheda and s.Cliente = se.Cliente)
		WHERE s.Cliente = var_CF_Cliente and DataInizio = var_dataScheda
        Order by Posizione;
		-- PENSO SIA GIUSTA MA NON SE SA MAI, FATTELA RICONTROLLA
        
	commit ;
END





CREATE DEFINER=`root`@`localhost` PROCEDURE `termina_sessione`(in var_dataSessione date, 
	in var_OrarioInizio time,
    in var_dataInizioScheda date,
    in var_cfClienti varchar(20))
BEGIN
	
    declare var_time time;
    declare exit handler for sqlexception
	begin 
		rollback;
		resignal;
	end;
    IF (PalestraDB.check_init_session(var_cfClienti, var_dataInizioScheda) = 3) THEN 
		signal sqlstate '45003' set message_text = 'DEVI INIZIARE UNA SESSIONE, PRIMA DI PER POTERLA TERMINARE.';
	END IF;
	start transaction;
		set var_time = curtime();
		
        UPDATE SessioneDiAllenamento
		SET  OrarioFine = curtime()
		WHERE Cliente = var_cfClienti
			AND  dataInizioScheda = var_dataInizioScheda
			AND OrarioInizio = var_OrarioInizio
            AND dataSessione = var_dataSessione;

    commit;
END





CREATE DEFINER=`root`@`localhost` PROCEDURE `visualizza_scheda_attiva`(in var_cfClienti varchar(20))
BEGIN
	declare var_Dat date;
	-- SET TRANSACTION ISOLATION LEVEL READ COMMITTED ;
	start transaction;
    
		SELECT DataInizio into var_Dat
        FROM Scheda
        WHERE DataFine is NULL and Cliente = var_cfClienti;
        
        SELECT *
        FROM SchedaEsercizi
        WHERE Cliente = var_cfClienti and dataInizioScheda = var_Dat
        order by Posizione;
        
	commit ;
END






CREATE DEFINER=`root`@`localhost` PROCEDURE `visualizza_schede_archiviate`(in var_cfClienti varchar(20))
BEGIN
    -- SET TRANSACTION ISOLATION LEVEL READ COMMITTED ;
	start transaction;
	
		SELECT DataInizio, DataFine
        FROM Scheda
        WHERE DataFine is not NULL and Cliente = var_cfClienti
		ORDER BY DataInizio ASC;
		-- PENSO SIA GIUSTA MA NON SE SA MAI, FATTELA RICONTROLLA
        
	commit ;
END





CREATE DEFINER=`root`@`localhost` PROCEDURE `visualizza_serie_esercizio`(in var_cfCliente varchar(20))
BEGIN
	-- SET TRANSACTION ISOLATION LEVEL READ COMMITTED ;
	start transaction;
    
		SELECT *
		FROM EserciziSvolti
		WHERE Clienti = var_cfCliente
		ORDER BY dataInizioScheda DESC, dataSessione DESC
		LIMIT 1;
        
		-- FATTELA RICONTROLLA
	commit ;
END






















CREATE DEFINER=`root`@`localhost` FUNCTION `check_cf`(CF VARCHAR(20)) RETURNS tinyint(1)
    DETERMINISTIC
BEGIN
    
    IF CF REGEXP '^[A-Z]{6}[0-9]{2}[A-Z][0-9]{2}[A-Z][0-9]{3}[A-Z]$' THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END




CREATE DEFINER=`root`@`localhost` FUNCTION `check_init_session`(CF VARCHAR(20), dataInitScheda date) RETURNS int
    DETERMINISTIC
BEGIN
	declare var_result INT;
	
	IF EXISTS (
		SELECT 1
		FROM SessioneDiAllenamento
		WHERE Clienti = CF
			AND dataInizioScheda = dataInitScheda
			AND OrarioInizio IS NOT NULL
			AND OrarioFine IS NULL
	) THEN
		SET var_result = 1; -- 1 = Sessione Iniziata ma non finita
	ELSEIF EXISTS (
		SELECT 1
		FROM SessioneDiAllenamento
		WHERE Clienti = CF
			AND dataInizioScheda = dataInitScheda
			AND OrarioInizio IS NOT NULL
			AND OrarioFine IS NOT NULL
	) THEN 
		SET var_result = 2; -- 2 = Sessione Iniziata e Finita
	ELSE
		SET var_result = 3; -- 3 = Sessione non iniziata
	END IF;
	RETURN var_result;
END





CREATE DEFINER=`root`@`localhost` FUNCTION `check_ex_status_function`(CF VARCHAR(20), dataInitScheda date, esercizio VARCHAR(20), dataSession date) RETURNS int
    DETERMINISTIC
BEGIN	
	IF EXISTS (
		SELECT 1
		FROM EserciziSvolti
		WHERE Clienti = CF
			AND dataInizioScheda = dataInitScheda
			AND dataSessione = dataSession 
			AND Esercizio = esercizio
            AND SerieCorrente >=1
	) THEN
		RETURN 1; -- Esercizio Iniziato ma non finito
	ELSE
		RETURN 2; -- Esercizio non iniziato
	END IF;
END